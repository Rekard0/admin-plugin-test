interface IPlugin {
  id: ID! # Plugin Address
  daoAddress: Bytes!
  pluginAddress: Bytes!
}

type AdminPlugin implements IPlugin @entity {
  id: ID! # Plugin Address
  daoAddress: Bytes!
  pluginAddress: Bytes!
  proposals: [AdminProposal!]! @derivedFrom(field: "plugin")
  administrators: [AdministratorAdminPlugin!]! @derivedFrom(field: "plugin")
}

type Administrator @entity(immutable: true) {
  id: ID! # Administrator Address
  address: String # address as string to facilitate filtering by address on the UI
  proposals: [AdminProposal!]! @derivedFrom(field: "administrator")
  plugins: [AdministratorAdminPlugin!]! @derivedFrom(field: "administrator")
}

type AdministratorAdminPlugin @entity {
  "for Many-to-Many"
  id: ID! # Plugin Address + Administrator Address
  administrator: Administrator!
  plugin: AdminPlugin!
}

interface IProposal {
  id: ID! # Plugin Address + proposalId
  daoAddress: Bytes!
  creator: Bytes!
  metadata: String
  actions: [Action!]! @derivedFrom(field: "proposal")
  allowFailureMap: BigInt!
  executed: Boolean!
  createdAt: BigInt!
  startDate: BigInt!
  endDate: BigInt!
  executionTxHash: Bytes
}

type AdminProposal implements IProposal @entity {
  id: ID! # Plugin Address + proposalId
  daoAddress: Bytes!
  creator: Bytes! # Administrator address
  metadata: String
  actions: [Action!]! @derivedFrom(field: "proposal")
  allowFailureMap: BigInt!
  executed: Boolean!
  createdAt: BigInt!
  startDate: BigInt!
  endDate: BigInt!
  plugin: AdminPlugin!
  pluginProposalId: BigInt!
  administrator: Administrator!
  executionTxHash: Bytes
}

interface IAction {
  id: ID! # Plugin Address + DAO Address + Plugin Proposal ID + action idx
  to: Bytes!
  value: BigInt!
  data: Bytes!
  daoAddress: Bytes!
}

type Action implements IAction @entity(immutable: true) {
  id: ID! # Plugin Address + DAO Address + Plugin Proposal ID + action idx
  to: Bytes!
  value: BigInt!
  data: Bytes!
  daoAddress: Bytes!

  # proposal data
  proposal: IProposal!
}
